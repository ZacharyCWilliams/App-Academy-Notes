## Ruby on Rails: Overview

**Why Rails:**

* Easy to deploy to production
* Built off Ruby which is very readable, easy to understand, and a "joy to use" (Beginner friendly)
* Open source framework that has a lot of external libraries (RubyGems)
* Large, active community
* Follows a number of good design principles

## Design Principles  

1. **MVC**

Rails is a MVC framework! This means it divides an application into a Model, a View, and a Controller.

1. The `Model` retrieves information from storage and performs logic upon that information.
2. The `View` presents information
3. The `Controller` constructs the server's HTTP response and sends commands to the Model to fetch/update information.

Note: The controller is the interface between the model and view. (An **interface** is a point where two systems, subjects, organizations, etc. meet and interact)

2. **CoC**

Rails uses convention over configuration. This means that the default configuration is already programmed into the framework, and developers only have to be specific upon doing something unconventional. **This reduces workload!** 

It does this, mainly, through naming conventions! If we name our database table `cats`, the default model name becomes `Cat`, and the default controller becomes `CatsController`. When rails sees these names in conjunction with one another it will automatically know how to load the pieces together.

3. **REST**

The principle behind using REST, or Representational State Transfer is to use standard operations, in combination with particular resource identifiers to produce standard/predictable results. We use these operations to gain access to web resources (documents, images, webpages, etc.)

Example:
```
In HTTP, a GET request to a resource with a specified id returns data 
on the item, regardless of what type of resource/item it is. 
```
Rails uses it's `resources` method which automatically generates `routes` by linking HTTP verbs and URI's to Contoller actions.

## Components

**ActiveRecord**

All models in rails inherit from ActiveRecord. It represents data from our database as Ruby objects, which can then be easily manipulated/presented.

Contains methods which implement basic **Create, Read, Update, Delete** (CRUD) functionality. This mirros SQL queries

**ActionController**

ActionController handles the controller logic. This is where we store information about the session or brief error messages (through cookies). It also checks for authenticity tokens! (This is how we protect against website attacks)

**ActionView**

ActionView renders the view. We will be doing this through ERB (Embedded Ruby) or JSON

**Rack**

Rack sits between the Router and Puma webserver! It recieves requests and generates responses through the information it gets from the router.

**Rake**

A utility tool that we use to carry out administrative tasks (migrating a database, displaying routes, etc).

**Puma**

Puma is a small library that provides a very fast HTTP server for Ruby web applications.

## Competing Frameworks

**Django (Python)**

Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design.

* Ruby was built to be "a joy to use"
* Python was designed around "a clean syntax and code readability"

Simularities:

Both use the MVC design principle. 

Differences:

Instead of using CoC, Python uses an "explicit is better" principle. This makes Django easier to read/understand but a little bit slower to write (No `rails magic`).

## How to start a new rails project

Run `rails new my_project_name -G --database=postgresql`. Rails will now set up the project!

Note: If we just use `rails new FileName` rails will auto default to using a sql3 database.

**Gems we want to add:**

* `gem 'pry-rails'`
* `gem 'better_errors'`
* `gem 'binding_of_caller'`
* `gem 'pry-rails'`

After adding gems run `bundle install`.

## Navigating the project

We will be writing the majority of our code in our `app` folder.

**models**

This is where we will be writing our classes that will interact with sql database directly.

**controllers**

This reads the request and figures out what the response will be.

**configuration**

We will create urls in `routes.rb` that will invoke specific controller actions.

**db**

We create all of our migrations, seeds, and schema will be generated inside of `seeds.rb`

## Migrations

**Overview**

1. We need a way to track the evolution of our db schema
2. We need a way to record transformations we've made to the db locally

ActiveRecord Migrations handle both of these tasks. A migration is a file containing Ruby code that describes a set of changes applied to the database. Each new set of changes (create/drop table, add/remove column) is written inside a new migration file, which is checked into the git repository.

**Intro: ActiveRecord Migrations allow us to write SQL commands in ruby.**

Before we can make migrations, we'll need to create a database!

**To Create A Database**

`bundle exec rails db:create`

**To View The Database**

`psql db_name`

**Our First Migration**

To create the table run `bundle exec rails g migration createTablename`

Our new migration (table) will appear in the `migrate` folder under `db`.

It may look like:

```ruby
class CreateDogs < ActiveRecord::Migration[5.0]
  def change
    create_table :dogs do |t|

    end
  end
end
```

Now that we have our table we can add a modification. 

`t.string :name, null: false`

We now have:

```ruby
class CreateDogs < ActiveRecord::Migration[5.0]
  def change
    create_table :dogs do |t|
      t.string :name, null: false
    end
  end
end
```

This hasn't been saved to our database yet. In order to save it we will now run our first migration. Run `bundle exec rails db:migrate`. This will update our database schema!

**Changing Migrations**

Let's add a color to our dogs table! 

Run `bundle exec g migration addColorToDogs` to generate our migration:

```ruby
class AddColorToDogs < ActiveRecord::Migration[5.0]
  def change
    
  end
end
```

We now add our color column using the `add_column` method:

`add_column :dogs, color, :string, null: false`

So our table now looks like this:

```ruby
class AddColorToDogs < ActiveRecord::Migration[5.0]
  def change
    add_column :dogs, color, :string, null: false
  end
end
```

We are now ready to migrate (save this migration to our database)! Let's run `bundle exec rails db:migrate`

**Rolling Back Migrations**

We roll back migrations because we cannot edit them. We do this by running rails `db:rollback`

## Object Relational Mapping (ORM)

We now have a database (SQL), and we know how to make changes to that database in rails (Migrations), but we need to learn how to use the records inside of our database! That's where ORM comes in:

The ActiveRecord ORM converts the SQL rows into ruby objects on fetch so that we can use them..

and then converts them back into SQL rows to save them to our database! 
























